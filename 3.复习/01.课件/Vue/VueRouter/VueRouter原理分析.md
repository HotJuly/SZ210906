# VueRouter原理分析

1. VueRouter的用处
   1. 他是Vue的插件库(Vue.use)
   2. 可以用于实现SPA应用(单页面应用)
   3. 问题:什么是单页面?
      1. 页面->html文件
      2. 整个项目打包结束之后,只有一个html文件的项目被称为单页面应用
      3. 单页面应用就是在一个html文件上,使用原生DOM的CRUD(增删改查)方法,对页面的内容进行操作,从而使得页面显示的内容进行局部更新效果
   4. 问题:Vue不使用VueRouter能否实现单页面应用效果?
      1. 可以,也就是说VueRouter其实并不是一个必须使用的库
      2. 其实,单页面应用概念并不是到了Vue或者React才出现的
   5. **小总结:如果当前项目的页面并不复杂,那么完全可以不使用VueRouter**
2. VueRouter给我们提供了什么?
   1. 构造函数
      1. 通过构造调用VueRouter函数可以得到一个路由器实例对象
   2. 全局组件
      1. router-view
         1. 该组件用于显示匹配当前路径的路由组件(占位符)
         2. 原理:该组件使用到了响应式原理,当地址发生变化的时候,页面会渲染出最新内容组件
      2. router-link
         1. 该组件用于生成a标签引导用户进行路由跳转
         2. 他是声明式导航的一员
            1. **声明式导航就是通过标签引导用户进行跳转的一种方式**
         3. 面试题:请问普通的a标签和router-link生成的a标签有什么区别?
            1. 普通的a标签被点击之后,会控制浏览器发送请求,从而获取到最新的页面进行展示
            2. 而router-link生成的a标签,点击之后,并不会发送请求,虽然会实现路由跳转功能,但是其实只是一个伪跳转
         4. **原理:其实router-link就是将a标签禁用了默认行为,然后绑定了点击事件,使用了编程式导航来控制用户路由跳转**
   3. 公共对象
      1. $router
         1. 他是路由器实例对象
         2. 它主要提供的是操作路由器的方法
            1. push
               1. 控制路由器进行路由跳转,当前方法跳转不会销毁上一个的历史记录
               2. 他是编程式导航的一员
                  1. **编程式导航就是通过js的API控制用户进行跳转的一种方式**
            2. replace
               1. 控制路由器进行路由跳转,当前方法跳转会销毁上一个的历史记录(返回不了上一个路由了)
               2. 他是编程式导航的一员
      2. $route
         1. 他是路由实例对象
         2. 它主要提供的是与当前所显示的路由相关的信息
            1. path->当前路由路径
            2. query->当前路由接收的query参数
               1. 格式:/home?keyword=华为
            3. params->当前路由接收的params参数
               1. 格式:/home/001
            4. meta->当前路由接收的meta参数
3. 我们需要给VueRouter提供什么?
   1. 配置对象
      1. mode属性(默认值为hash)
         1. 数据类型:string
         2. **hash**
            1. **用于声明当前路由格式为hash模式**
            2. **路由格式:在域名和端口号之后会有"/#/"**
            3. **优点:**
               1. **兼容性好,兼容IE6+**
               2. **由于/#/之后的路由地址不会被作为后端路由进行解析,所以不需要做出任何配置**
            4. **缺点:**
               1. **#后面的内容会被当做锚点使用,最终会导致锚点功能失效**
               2. **地址中自带/#/,太丑了**
            5. **原理:**
               1. **使用window.location.hash="需要跳转的路径"来控制浏览器历史记录栈的跳转,同时不会发送请求,实现路由跳转功能**
               2. **通过给window绑定hashchange事件可以监视地址栏hash值的变化,当hash值变化时,会触发回调函数,在回调函数中通知视图进行更新(可以监视到浏览器的前进后退按钮的变化)**
         3. **history**
            1. **用于声明当前路由格式为history模式**
            2. **路由格式:在域名和端口号之后会有"/"**
            3. **优点:**
               1. **颜值就是正义,好看就行**
               2. **锚点功能可以正常使用**
            4. **缺点:**
               1. **兼容性差,兼容IE10+**
               2. **使用history模式,需要后端服务器进行配合,否则将会请求失败**
                  1. **流程:**
                     1. **前言:一般后端会将当前网址的根路径/配置为返回html文件**
                     2. **用户处于"http://localhost:8080/about"地址下,刷新浏览器,此时浏览器会将/about视为后端路由,发送给后端**
                     3. **后端接收到/about路由的请求,开始匹配后端路由/about**
                     4. **后端最终没找到/about路由,返回404**
                     5. **前端最终展示404报错**
                  2. **解决方案:**
                     1. **要求后端将他没有的路由接口,统一返回项目的html文件**
                     2. **流程:**
                        1. **用户处于"http://localhost:8080/about"地址下,刷新浏览器,此时浏览器会将/about视为后端路由,发送给后端**
                        2. **后端接收到/about路由的请求,开始匹配后端路由/about**
                        3. **端最终没找到/about路由,会自动返回html文件**
                        4. **前端接收到html文件,会请求index.js文件**
                        5. **服务器返回index.js文件,js文件的VueRouter代码会自动执行**
                        6. **VueRouter发现当前地址栏中的/about路由,就会成功展示对应的路由组件**
                  3. **小总结:/about其实是前端路由,此案例的错误点就在于被是为了后端路由,通过返回html文件,最终实现将该路由作为前端路由进行解析**
            5. **原理:**
               1. **通过window.history.pushState/replaceState方法可以控制浏览器历史记录栈的变化,同时不会发送请求,实现路由跳转功能**
               2. **通过给window绑定popstate事件可以监视地址栏路由的变化,当路由变化时,会触发回调函数,在回调函数中通知试图进行更新(无法见识到pushState和replaceState对地址的修改,可以监视到浏览器的前进后退按钮的变化)**
      2. routes属性
         1. 数据类型:routeObj[]
         2. 用于存储所有的路由信息对象
         3. routeObj对象属性
            1. path属性
               1. 当前路由映射关系中的路由路径
            2. component
               1. 当前路由映射关系中的路由组件(当地址栏中的地址与path相同时,需要显示的组件信息)