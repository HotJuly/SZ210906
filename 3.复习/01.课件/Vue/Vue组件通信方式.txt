1.props
	适用场景:父子组件通信
	props会实现接收标签属性的结果

	父传子
	流程:
		父组件将数据通过子组件标签的标签属性进行传递
		子组件声明props,用于接收父组件传递的属性

		父组件传递的是真正的数据

	子传父
	流程:
		父组件通过标签属性将自己methods中的函数传递给子组件
		子组件通过props接受父组件传递下来的函数
		子组件调用该函数,并向函数内部传入数据

		父组件传递的是接收数据的函数
			注意:因为组件methods中的方法,this已经被强行指定为当前组件实例对象

		
2.provide/inject
	适用场景:祖孙组件通信
	流程:
		1.祖先组件通过在配置对象中添加provide属性,属性值为一个对象
		2.后代组件通过在配置对象中添加inject属性,属性值为数组,数组内部书写需要接收的provide属性
		3.后代组件可以将接收到的provide数据作为data进行使用

	注意:
		1.provide暴露的数据默认不是响应式对象,所以没有响应式的特点
		2.可以使用Vue.observable方法将一个对象变成响应式对象,然后在通过provide暴露给后代组件使用
		3.可以在祖先组件中,通过this._provided找到暴露出去的provide数据,并对其进行修改

3.自定义事件
	$on	->	用于给某个组件实例对象绑定自定义事件
	$emit	->	用于触发某个实例对象身上的某个或者某类自定义事件
	$once	->	用于给某个组件实例对象绑定自定义事件,但是绑定的自定义事件只能触发一次,之后就会自动解绑
	$off	->	用于将某个组件实例对象上的某个或者某类自定义事件解绑


	v-model(双向数据绑定)
		两种使用方式
			对input标签使用
				1.将data中的状态数据做为input框的默认值进行展示
				2.当input框的内容发生变化时,同步修改data中对应的状态数据
					监听的事件名:input

    				<input type="text" :value="msg" @input="handleInput">

			对组件标签使用
				1.将data中的状态数据作为组件的标签属性进行传递(默认属性名为value)
				2.给子组件标签绑定了自定义事件,当子组件触发该自定义事件,可以通知父组件对状态进行修改(默认事件名为input)

    				<HelloWorld :value="msg" @input="data=>msg=data"/>


			注意:配置对象中的model属性,可以自定义当前组件接受的v-model的属性名以及事件名称

	.sync(修饰符)
		1.将data中的状态数据作为组件的标签属性进行传递(属性名自己取)
		2.给子组件标签绑定了自定义事件,当子组件触发该自定义事件,可以通知父组件对状态进行修改(事件名称"update:"+属性名)

    		<HelloWorld :username="username" @update:username="data=>username=data"/>

	全局事件总线
		流程:
			1.创建一个Vue实例对象,并且将该对象放在Vue的原型对象身上(属性名可以任意取名,但是必须存储着Vue的实例对象)
				Vue.prototype.$myBus = new Vue();

			2.需要接收数据的组件,使用this.$myBus.$on绑定自定义事件,用于接收数据
   				 this.$myBus.$on("sendMsg",(data)=>{
     				 	// console.log('sendMsg',data)
      					this.username = data;
   				 })

			3.需要发送数据的组件,使用this.$myBus.$emit触发自定义事件,用于传递数据
     				 this.$myBus.$emit('sendMsg',"老王")

			注意:
				1.当组件卸载的时候,一定要将该组件绑定的全局事件总线进行解绑处理,防止自定义事件遗留,导致内存溢出
				2.订阅者和发布者必须同时存在
				3.订阅操作必须在发布操作之前触发


4.找到对应的组件实例对象
	1.$parent
		通过this.$parent可以获取到父组件的实例对象,从而获取到父组件的所有内容(父组件能看到,你都能得到)

	2.$root
		通过this.$root可以获取到根组件实例对象

	3.$children
		通过this.$children可以获取到子组件的实例对象组成的数组

		注意:$children 并不保证顺序，也不是响应式的
			如果子组件存在异步组件的情况,该数组中的顺序与页面上显示顺序会不相同
			就算将该数组中的内容顺序进行调换,页面上的组件展示顺序也不会发生变化

	4.$refs
		使用方法:
			1.在当前组件的template中,给某些标签或者组件添加上ref标签属性
			2.在组件代码中,使用this.$refs.标识名称就可以找到对应的组件或者标签
		
		对标签使用
			可以获得被标记的元素,挂载之后的真实DOM

		对组件使用
			可以获得被标记的组件生成的实例对象

5.$attrs,$listeners
	$attrs->用于将父组件传递下来,同时没有被子组件通过props接受的标签属性进行接收
		类似于垃圾桶,专门捡props不要的东西

	$listeners->用于收集当前组件身上绑定的所有自定义事件


6.插槽
	插槽一共分为三种
		以下三种插槽都适用于父向子传参的场景,只不过传递的不是数据而是页面结构

	默认插槽
		1.父组件通过给子组件的标签中传入一段页面结构(想使用插槽子组件标签必须是成对标签)
		2.子组件通过slot组件来告知Vue,需要在哪块区域渲染插槽的内容

	具名插槽
		1.父组件在传递结构给子组件的同时,在插槽上使用v-slot:名称的格式给插槽取名
		2.子组件在使用slot组件的时候,添加name标签属性,可以显示对应的插槽
	
		v-slot:可以简写为#

	作用域插槽
		1.基于具名插槽的流程,父组件会将结构传递给子组件
		2.在子组件中,可以给slot组件添加标签属性
			注意:传递给slot标签的所有标签属性都会生成一个对象(类似于props)
		3.在父组件传递插槽的时候,可以书写v-slot:名称="变量名"
			注意:该变量中会存储slot接收的所有标签属性(也就是那个类似于props的对象)
		4.在插槽中使用该对象配置插值语法进行数据使用渲染

		作用域插槽其实并不算是子向父传参,他只有父向子传参,slot组件其实就相当于是一个占位符,它内部会渲染传递下来的插槽

	注意:如果只有一个标签或者组件,可以不书写template进行包裹


7.Vuex




















